package su.kaoyu.glyph.dao;

import su.kaoyu.glyph.dao.DaoSession;
import de.greenrobot.dao.DaoException;

import de.greenrobot.dao.AbstractDao;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table "GLYPH_SEQUENCE".
 */
public class GlyphSequence {

    private Long id;
    private int glyphNum;
    private long glyphId1;
    private Long glyphId2;
    private Long glyphId3;
    private Long glyphId4;
    private Long glyphId5;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient GlyphSequenceDao myDao;

    private Glyph glyph1;
    private Long glyph1__resolvedKey;

    private Glyph glyph2;
    private Long glyph2__resolvedKey;

    private Glyph glyph3;
    private Long glyph3__resolvedKey;

    private Glyph glyph4;
    private Long glyph4__resolvedKey;

    private Glyph glyph5;
    private Long glyph5__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public GlyphSequence() {
    }

    public GlyphSequence(Long id) {
        this.id = id;
    }

    public GlyphSequence(Long id, int glyphNum, long glyphId1, Long glyphId2, Long glyphId3, Long glyphId4, Long glyphId5) {
        this.id = id;
        this.glyphNum = glyphNum;
        this.glyphId1 = glyphId1;
        this.glyphId2 = glyphId2;
        this.glyphId3 = glyphId3;
        this.glyphId4 = glyphId4;
        this.glyphId5 = glyphId5;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getGlyphSequenceDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public int getGlyphNum() {
        return glyphNum;
    }

    public void setGlyphNum(int glyphNum) {
        this.glyphNum = glyphNum;
    }

    public long getGlyphId1() {
        return glyphId1;
    }

    public void setGlyphId1(long glyphId1) {
        this.glyphId1 = glyphId1;
    }

    public Long getGlyphId2() {
        return glyphId2;
    }

    public void setGlyphId2(Long glyphId2) {
        this.glyphId2 = glyphId2;
    }

    public Long getGlyphId3() {
        return glyphId3;
    }

    public void setGlyphId3(Long glyphId3) {
        this.glyphId3 = glyphId3;
    }

    public Long getGlyphId4() {
        return glyphId4;
    }

    public void setGlyphId4(Long glyphId4) {
        this.glyphId4 = glyphId4;
    }

    public Long getGlyphId5() {
        return glyphId5;
    }

    public void setGlyphId5(Long glyphId5) {
        this.glyphId5 = glyphId5;
    }

    /** To-one relationship, resolved on first access. */
    public Glyph getGlyph1() {
        long __key = this.glyphId1;
        if (glyph1__resolvedKey == null || !glyph1__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GlyphDao targetDao = daoSession.getGlyphDao();
            Glyph glyph1New = targetDao.load(__key);
            synchronized (this) {
                glyph1 = glyph1New;
            	glyph1__resolvedKey = __key;
            }
        }
        return glyph1;
    }

    public void setGlyph1(Glyph glyph1) {
        if (glyph1 == null) {
            throw new DaoException("To-one property 'glyphId1' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.glyph1 = glyph1;
            glyphId1 = glyph1.getId();
            glyph1__resolvedKey = glyphId1;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Glyph getGlyph2() {
        Long __key = this.glyphId2;
        if (glyph2__resolvedKey == null || !glyph2__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GlyphDao targetDao = daoSession.getGlyphDao();
            Glyph glyph2New = targetDao.load(__key);
            synchronized (this) {
                glyph2 = glyph2New;
            	glyph2__resolvedKey = __key;
            }
        }
        return glyph2;
    }

    public void setGlyph2(Glyph glyph2) {
        synchronized (this) {
            this.glyph2 = glyph2;
            glyphId2 = glyph2 == null ? null : glyph2.getId();
            glyph2__resolvedKey = glyphId2;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Glyph getGlyph3() {
        Long __key = this.glyphId3;
        if (glyph3__resolvedKey == null || !glyph3__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GlyphDao targetDao = daoSession.getGlyphDao();
            Glyph glyph3New = targetDao.load(__key);
            synchronized (this) {
                glyph3 = glyph3New;
            	glyph3__resolvedKey = __key;
            }
        }
        return glyph3;
    }

    public void setGlyph3(Glyph glyph3) {
        synchronized (this) {
            this.glyph3 = glyph3;
            glyphId3 = glyph3 == null ? null : glyph3.getId();
            glyph3__resolvedKey = glyphId3;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Glyph getGlyph4() {
        Long __key = this.glyphId4;
        if (glyph4__resolvedKey == null || !glyph4__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GlyphDao targetDao = daoSession.getGlyphDao();
            Glyph glyph4New = targetDao.load(__key);
            synchronized (this) {
                glyph4 = glyph4New;
            	glyph4__resolvedKey = __key;
            }
        }
        return glyph4;
    }

    public void setGlyph4(Glyph glyph4) {
        synchronized (this) {
            this.glyph4 = glyph4;
            glyphId4 = glyph4 == null ? null : glyph4.getId();
            glyph4__resolvedKey = glyphId4;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Glyph getGlyph5() {
        Long __key = this.glyphId5;
        if (glyph5__resolvedKey == null || !glyph5__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            GlyphDao targetDao = daoSession.getGlyphDao();
            Glyph glyph5New = targetDao.load(__key);
            synchronized (this) {
                glyph5 = glyph5New;
            	glyph5__resolvedKey = __key;
            }
        }
        return glyph5;
    }

    public void setGlyph5(Glyph glyph5) {
        synchronized (this) {
            this.glyph5 = glyph5;
            glyphId5 = glyph5 == null ? null : glyph5.getId();
            glyph5__resolvedKey = glyphId5;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public Glyph[] getGlyphSequence() {
        Glyph[] glyphSequence = new Glyph[glyphNum];
        switch (glyphNum) {
            case 5:
                glyphSequence[4] = getGlyph5();
            case 4:
                glyphSequence[3] = getGlyph4();
            case 3:
                glyphSequence[2] = getGlyph3();
            case 2:
                glyphSequence[1] = getGlyph2();
            case 1:
                glyphSequence[0] = getGlyph1();
            default:
                break;
        }
        return glyphSequence;
    }

    @Override
    public boolean equals(Object o) {
        if (o != null && o instanceof GlyphSequence && glyphNum == ((GlyphSequence) o).glyphNum) {
            switch (glyphNum) {
                case 5:
                    if (!glyphId5.equals(((GlyphSequence) o).glyphId5)) {
                        return false;
                    }
                case 4:
                    if (!glyphId4.equals(((GlyphSequence) o).glyphId4)) {
                        return false;
                    }
                case 3:
                    if (!glyphId3.equals(((GlyphSequence) o).glyphId3)) {
                        return false;
                    }
                case 2:
                    if (!glyphId2.equals(((GlyphSequence) o).glyphId2)) {
                        return false;
                    }
                case 1:
                    return glyphId1 == ((GlyphSequence) o).glyphId1;
                default:
                    break;
            }
            return true;
        }
        return false;
    }
    // KEEP METHODS END

}
